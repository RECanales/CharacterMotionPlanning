using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Graph;

public class Animate : MonoBehaviour
{
    public GameObject character;
    public Transform startPos, endPos, roadmapArea;
    public float maxSamples, minSpacing, circleRadius;
    public bool debug = false;
    Planner roadmap;
    Roadmap graph = null;
    List<RoadmapVertex> path;
    int path_index, next_index;
    Vector2 motion;
    Vector3 cachedPos, cachedFwd, cachedRight;
    float cachedDist;
    Animator animator;
    AnimatorClipInfo[] m_CurrentClipInfo;

    void Start()
    {
        roadmap = GameObject.FindGameObjectWithTag("Roadmap").GetComponent<Planner>();
        roadmap.InitObstacles();
        //graph = roadmap.BuildRoadmap((int)maxSamples, roadmapArea.localScale.x, roadmapArea.localScale.y, minSpacing, circleRadius);
        path = roadmap.FindPath(graph, character.transform, endPos);   // update with character position
        animator = character.GetComponent<Animator>();

        if (path.Count > 1)
        {
            if (debug)
                ShowPath();

            Vector3 dir = Vector3.Normalize(path[1].GetPosition() - path[0].GetPosition());
            character.transform.position = new Vector3(path[0].GetPosition().x, 0, path[0].GetPosition().z);
            character.transform.forward = new Vector3(dir.x, 0, dir.z);

            path_index = 0;
            next_index = 1;
            cachedPos = character.transform.position;
            UpdateMotion(path_index, next_index);
        }
    }

    void UpdateMotion(int path_index, int next_index)
    {
        //Vector3 translate = path[next_index].GetConfiguration() - path[path_index].GetConfiguration();
        //translate = new Vector3(translate.x, 0, translate.z).normalized;

        Transform hip = character.transform.GetChild(1).GetChild(0);

        Vector3 translate = path[next_index].GetConfiguration() - hip.position;
        translate = new Vector3(translate.x, 0, translate.z);

        Quaternion newRotation = Quaternion.LookRotation(translate, Vector3.up);
        Vector3 forward = newRotation * new Vector3(0, 0, 1);
        Vector3 cForward = new Vector3(hip.forward.x, 0, hip.forward.z).normalized;
        Vector3 cRight = new Vector3(hip.right.x, 0, hip.right.z).normalized;

        float x = Vector3.Dot(translate, cRight);
        float y = Vector3.Dot(translate, cForward);


        Vector3 point = x * Vector3.right + y * Vector3.forward;

        // testing
        point = Quaternion.Inverse(hip.rotation) * translate;

        Debug.DrawLine(startPos.position, startPos.position + point, Color.black, 0.5f);

        motion = new Vector2(point.x, point.z).normalized;
        //motion = new Vector2(0, Mathf.Pow(Vector3.Magnitude(hip.position - endPos.position), 2));
    }

    void Update()
    {
        if (graph != null && path.Count > 1)
        {
            if (next_index < path.Count - 1)
            {
                Vector3 from_to = path[next_index].GetConfiguration() - path[path_index].GetConfiguration();
                from_to = new Vector3(from_to.x, 0, from_to.z);
                Vector3 from_to_char = character.transform.position - path[path_index].GetConfiguration();
                from_to_char = new Vector3(from_to_char.x, 0, from_to_char.z);

                //Vector3 test = new Vector3(character.transform.position.x, 0, character.transform.position.z) - proxyPosition;

                if (from_to_char.magnitude >= from_to.magnitude)
                {
                    path_index++;
                    next_index++;

                    //proxyPosition = new Vector3(character.transform.position.x, 0, character.transform.position.z);

                    //Vector3 dir = Vector3.Normalize(path[next_index].GetConfiguration() - path[path_index].GetConfiguration());
                    //dir = path[next_index].GetConfiguration() - character.transform.position;
                    //motion = new Vector2(dir.x, -dir.z).normalized;
                    //motion = new Vector2(0, 1);

                    //Debug.DrawLine(character.transform.position + new Vector3(0, 1, 0), character.transform.position + new Vector3(0, 1, 0) + 0.5f * forward, Color.blue, 0.5f);
                    //Debug.DrawLine(character.transform.position + new Vector3(0, 1, 0), character.transform.position + new Vector3(0, 1, 0) + 0.5f * right, Color.red, 0.5f);


                    //UpdateMotion(path_index, next_index);

                    /*
                    Vector3 forward = character.transform.position - cachedPos;
                    if (forward.magnitude <= 0)
                        forward = character.transform.forward;
                    forward = forward.normalized;
                    Quaternion newRotation = Quaternion.LookRotation(forward, Vector3.up);
                    //Transform hip = character.transform.GetChild(1).GetChild(0);
                    Vector3 translate = path[next_index].GetConfiguration() - character.transform.position;
                    translate = new Vector3(translate.x, 0, translate.z);
                    Vector3 point = Vector3.Normalize(Quaternion.Inverse(newRotation) * translate);

                    Debug.DrawLine(startPos.position, startPos.position + point, Color.black, 0.5f);

                    motion = new Vector2(point.x, point.z).normalized;
                    cachedPos = character.transform.position;
                    */


                }
            }

            Transform hip = character.transform.GetChild(1).GetChild(0);
            m_CurrentClipInfo = animator.GetCurrentAnimatorClipInfo(0);
            Vector3 forward = character.transform.rotation * m_CurrentClipInfo[0].clip.averageSpeed.normalized;
            forward = forward.normalized;
            Quaternion newRotation = Quaternion.LookRotation(forward, Vector3.up);
            //Transform hip = character.transform.GetChild(1).GetChild(0);
            Vector3 translate = path[next_index].GetConfiguration() - character.transform.position;
            translate = new Vector3(translate.x, 0, translate.z);
            Vector3 point = Vector3.Normalize(Quaternion.Inverse(newRotation) * translate);

            Debug.DrawLine(startPos.position, startPos.position + point, Color.black, 0.5f);


            /*
            Vector3 translate = path[next_index].GetConfiguration() - path[path_index].GetConfiguration();
            translate = new Vector3(translate.x, 0, translate.z).normalized;
            m_CurrentClipInfo = animator.GetCurrentAnimatorClipInfo(0);
            float velocity = Vector3.Magnitude(m_CurrentClipInfo[0].clip.averageSpeed) * m_CurrentClipInfo[0].weight;
            character.transform.position = character.transform.position + Time.deltaTime * new Vector3(translate.x, 0, translate.z) * velocity;
            */
            float velocity = Vector3.Magnitude(path[path.Count - 1].GetConfiguration() - character.transform.position);

            if (next_index < path.Count - 1)
                velocity = 1;

            motion = new Vector2(0, 1).normalized * velocity * 0.6f;
            newRotation = Quaternion.LookRotation(translate.normalized, Vector3.up);
            float rotation_speed = Vector3.Magnitude(path[next_index].GetConfiguration() - path[path_index].GetConfiguration()) * 10;
            character.transform.rotation = Quaternion.Slerp(character.transform.rotation, newRotation, rotation_speed * Time.deltaTime);
        }

        if(debug && graph != null)
        {
            for (int i = 0; i < graph.VertexCount(); ++i)
            {
                RoadmapVertex v = graph.GetVertices()[i];
                for (int j = 0; j < v.GetEdges().Count; ++j)
                {
                    Debug.DrawLine(v.GetConfiguration(), graph.GetVertices()[v.GetEdges()[j].GetId()].GetConfiguration());
                }
            }
        }
    }

    public Vector2 GetInputParams()
    {
        return motion;
    }

    void ShowPath()
    {
        for (int i = 0; i < path.Count; ++i)
        {
            GameObject tmp = GameObject.CreatePrimitive(PrimitiveType.Sphere);
            tmp.transform.localScale = new Vector3(0.05f, 0.05f, 0.05f);
            tmp.transform.position = new Vector3(path[i].GetConfiguration().x, 1, path[i].GetConfiguration().z);
        }
    }
}
